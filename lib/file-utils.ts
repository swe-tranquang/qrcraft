/**
 * File download and export utilities
 */

import QRCode from 'qrcode';
import jsPDF from 'jspdf';
import { QRCodeOptions } from '@/types';

/**
 * Generate QR code as SVG string
 */
export async function generateQRCodeSVG(options: QRCodeOptions): Promise<string> {
  const {
    text,
    size = 256,
    errorCorrectionLevel = 'M',
    foregroundColor = '#000000',
    backgroundColor = '#FFFFFF',
  } = options;

  if (!text.trim()) {
    throw new Error('Text input cannot be empty');
  }

  try {
    const svgString = await QRCode.toString(text, {
      type: 'svg',
      width: size,
      margin: 2,
      errorCorrectionLevel,
      color: {
        dark: foregroundColor,
        light: backgroundColor,
      },
    });

    return svgString;
  } catch (error) {
    console.error('SVG QR Code generation failed:', error);
    throw new Error('Failed to generate SVG QR code');
  }
}

/**
 * Generate QR code as PDF blob
 */
export async function generateQRCodePDF(options: QRCodeOptions): Promise<Blob> {
  const {
    text,
    size = 256,
    errorCorrectionLevel = 'M',
    foregroundColor = '#000000',
    backgroundColor = '#FFFFFF',
  } = options;

  if (!text.trim()) {
    throw new Error('Text input cannot be empty');
  }

  try {
    // Generate QR code as data URL for embedding in PDF
    const dataURL = await QRCode.toDataURL(text, {
      width: size,
      margin: 2,
      errorCorrectionLevel,
      color: {
        dark: foregroundColor,
        light: backgroundColor,
      },
    });

    // Create PDF with jsPDF
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });

    // Add title
    pdf.setFontSize(20);
    pdf.setFont('helvetica', 'bold');
    pdf.text('QRCraft - Generated QR Code', 20, 30);

    // Add QR code image
    const qrSize = Math.min(size / 3, 100); // Convert to mm and limit size
    const x = (210 - qrSize) / 2; // Center horizontally on A4 (210mm width)
    const y = 50;
    
    pdf.addImage(dataURL, 'PNG', x, y, qrSize, qrSize);

    // Add details
    pdf.setFontSize(12);
    pdf.setFont('helvetica', 'normal');
    
    const details = [
      `Content: ${text.length > 60 ? text.substring(0, 60) + '...' : text}`,
      `Size: ${size}Ã—${size}px`,
      `Error Correction: ${errorCorrectionLevel}`,
      `Generated: ${new Date().toLocaleString()}`,
      `Colors: ${foregroundColor} on ${backgroundColor}`
    ];

    details.forEach((detail, index) => {
      pdf.text(detail, 20, y + qrSize + 20 + (index * 8));
    });

    // Add footer
    pdf.setFontSize(10);
    pdf.setTextColor(128, 128, 128);
    pdf.text('Generated by QRCraft - qrcraft.app', 20, 280);

    // Return as blob
    return pdf.output('blob');
  } catch (error) {
    console.error('PDF QR Code generation failed:', error);
    throw new Error('Failed to generate PDF QR code');
  }
}

/**
 * Download file with given content and filename
 */
export function downloadFile(content: string | Blob, filename: string, mimeType?: string) {
  let url: string;
  
  if (content instanceof Blob) {
    // Handle Blob content (like PDF)
    url = URL.createObjectURL(content);
  } else if (content.startsWith('data:')) {
    // Handle data URL (like PNG from canvas)
    // For better compatibility, convert data URL to blob
    try {
      const blob = dataURLToBlob(content);
      url = URL.createObjectURL(blob);
    } catch (error) {
      console.warn('Failed to convert data URL to blob, using direct URL:', error);
      url = content;
    }
  } else {
    // Handle text content (like SVG)
    const blob = new Blob([content], { type: mimeType || 'text/plain' });
    url = URL.createObjectURL(blob);
  }
  
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  // Clean up the URL object
  setTimeout(() => {
    try {
      URL.revokeObjectURL(url);
    } catch (error) {
      // Ignore cleanup errors for data URLs
      console.debug('URL cleanup ignored:', error);
    }
  }, 100);
}

/**
 * Convert data URL to Blob
 */
function dataURLToBlob(dataURL: string): Blob {
  const arr = dataURL.split(',');
  const mime = arr[0].match(/:(.*?);/)?.[1] || 'image/png';
  const bstr = atob(arr[1]);
  let n = bstr.length;
  const u8arr = new Uint8Array(n);
  
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }
  
  return new Blob([u8arr], { type: mime });
}

/**
 * Copy content to clipboard
 */
export async function copyToClipboard(content: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(content);
    return true;
  } catch (error) {
    console.error('Failed to copy to clipboard:', error);
    return false;
  }
}

/**
 * Create filename with timestamp
 */
export function createFilename(prefix: string, extension: string): string {
  const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
  return `${prefix}-${timestamp}.${extension}`;
}